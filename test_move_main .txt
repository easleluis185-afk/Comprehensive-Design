#include <string.h>
#include <stdio.h>
#include <unistd.h>
#include "math.h"

#include "freertos/FreeRTOS.h"
#include "freertos/task.h"
#include "freertos/queue.h"
#include "esp_log.h"
#include "esp_system.h"
#include "esp_timer.h"

#include <uros_network_interfaces.h>
#include <rcl/rcl.h>
#include <rcl/error_handling.h>
#include <rclc/rclc.h>
#include <rclc/executor.h>
#include <rmw_microros/rmw_microros.h>
#include <micro_ros_utilities/string_utilities.h>
#include <geometry_msgs/msg/quaternion.h>

#include "car_motion.h"

#define RCCHECK(fn)                                                                      \
    {                                                                                    \
        rcl_ret_t temp_rc = fn;                                                          \
        if ((temp_rc != RCL_RET_OK))                                                     \
        {                                                                                \
            printf("Failed status on line %d: %d. Aborting.\n", __LINE__, (int)temp_rc); \
            vTaskDelete(NULL);                                                           \
        }                                                                                \
    }
#define RCSOFTCHECK(fn)                                                                    \
    {                                                                                      \
        rcl_ret_t temp_rc = fn;                                                            \
        if ((temp_rc != RCL_RET_OK))                                                       \
        {                                                                                  \
            printf("Failed status on line %d: %d. Continuing.\n", __LINE__, (int)temp_rc); \
        }                                                                                  \
    }

#define ROS_NAMESPACE      CONFIG_MICRO_ROS_NAMESPACE
#define ROS_DOMAIN_ID      CONFIG_MICRO_ROS_DOMAIN_ID
#define ROS_AGENT_IP       CONFIG_MICRO_ROS_AGENT_IP
#define ROS_AGENT_PORT     CONFIG_MICRO_ROS_AGENT_PORT

// 运动指令队列大小
#define MOTION_QUEUE_SIZE  20

static const char *TAG = "MAIN";

rcl_subscription_t quaternion_subscriber;

// 运动指令结构体
typedef struct {
    float x;
    float y;
    float z;
    float w;
} MotionCommand;

// FreeRTOS队列句柄
QueueHandle_t motion_queue = NULL;

// 运动处理任务句柄
TaskHandle_t motion_task_handle = NULL;

// 四元数消息接收回调函数
void quaternion_callback(const void *msgin)
{
    const geometry_msgs__msg__Quaternion *received_msg = (const geometry_msgs__msg__Quaternion *)msgin;
    
    // 创建运动指令
    MotionCommand cmd = {
        .x = received_msg->x,
        .y = received_msg->y,
        .z = received_msg->z,
        .w = received_msg->w
    };
    
    // 记录接收到的消息
    ESP_LOGI(TAG, "Received Quaternion: x:%.3f, y:%.3f, z:%.3f, w:%.3f", 
             cmd.x, cmd.y, cmd.z, cmd.w);
    
    // 尝试将命令放入队列（非阻塞方式，0 ticks超时）
    BaseType_t xStatus = xQueueSend(motion_queue, &cmd, 0);
    
    if (xStatus != pdPASS) {
        // 队列已满，记录警告
        ESP_LOGW(TAG, "Motion queue full, dropping command: x:%.3f, y:%.3f", cmd.x, cmd.y);
    } else {
        // 可选：记录队列深度用于监控
        UBaseType_t uxMessagesWaiting = uxQueueMessagesWaiting(motion_queue);
        if (uxMessagesWaiting > MOTION_QUEUE_SIZE / 2) {
            ESP_LOGW(TAG, "Motion queue filling up: %d/%d commands waiting", 
                     uxMessagesWaiting, MOTION_QUEUE_SIZE);
        }
    }
}

// 运动指令处理任务
void motion_processing_task(void *arg)
{
    MotionCommand cmd;
    BaseType_t xStatus;
    uint32_t queue_full_count = 0;
    uint32_t processed_count = 0;
    TickType_t last_wake_time = xTaskGetTickCount();
    
    ESP_LOGI(TAG, "Motion processing task started");
    
    while (1) {
        // 从队列接收命令（阻塞等待，直到有命令到达）
        xStatus = xQueueReceive(motion_queue, &cmd, portMAX_DELAY);
        
        if (xStatus == pdPASS) {
            processed_count++;
            
            // 记录正在处理的命令
            ESP_LOGI(TAG, "Processing command %lu: x:%.3f, y:%.3f, z:%.3f, w:%.3f", 
                     processed_count, cmd.x, cmd.y, cmd.z, cmd.w);
            
            // 执行运动控制
            Motion_Ctrl(cmd.x, cmd.y, cmd.z);
            
            // 如果w被用作延迟时间（毫秒）
            if (cmd.w > 0) {
                uint32_t delay_ms = (uint32_t)cmd.w;
                
                // 记录延迟信息
                if (delay_ms > 100) {
                    ESP_LOGI(TAG, "Applying delay: %lu ms", delay_ms);
                }
                
                // 使用vTaskDelay进行延迟
                vTaskDelay(pdMS_TO_TICKS(delay_ms));
            }
            
            // 每处理10个命令，报告一次状态
            if (processed_count % 10 == 0) {
                UBaseType_t queue_items = uxQueueMessagesWaiting(motion_queue);
                ESP_LOGI(TAG, "Status: processed=%lu, dropped=%lu, queue=%d/%d", 
                         processed_count, queue_full_count, queue_items, MOTION_QUEUE_SIZE);
            }
        }
        
        // 可选：添加最小循环周期以确保系统响应性
        // vTaskDelayUntil(&last_wake_time, pdMS_TO_TICKS(1));
    }
}

// 监控任务：定期检查队列状态和系统健康
void monitoring_task(void *arg)
{
    ESP_LOGI(TAG, "Monitoring task started");
    
    while (1) {
        vTaskDelay(pdMS_TO_TICKS(5000));  // 每5秒检查一次
        
        // 检查队列状态
        if (motion_queue != NULL) {
            UBaseType_t queue_items = uxQueueMessagesWaiting(motion_queue);
            UBaseType_t queue_spaces = uxQueueSpacesAvailable(motion_queue);
            
            // 如果队列经常接近满状态，可能需要调整队列大小或处理速度
            if (queue_items > MOTION_QUEUE_SIZE * 0.8) {
                ESP_LOGW(TAG, "Queue heavily loaded: %d/%d items", queue_items, MOTION_QUEUE_SIZE);
            }
            
            // 监控运动任务状态
            if (motion_task_handle != NULL) {
                eTaskState task_state = eTaskGetState(motion_task_handle);
                const char* state_str;
                switch(task_state) {
                    case eRunning: state_str = "Running"; break;
                    case eReady: state_str = "Ready"; break;
                    case eBlocked: state_str = "Blocked"; break;
                    case eSuspended: state_str = "Suspended"; break;
                    case eDeleted: state_str = "Deleted"; break;
                    default: state_str = "Unknown"; break;
                }
                ESP_LOGI(TAG, "Motion task state: %s", state_str);
            }
        }
        
        // 可选：监控系统内存
        ESP_LOGI(TAG, "Minimum free heap: %lu bytes", esp_get_minimum_free_heap_size());
    }
}

// micro_ros处理任务
void micro_ros_task(void *arg)
{
    rcl_allocator_t allocator = rcl_get_default_allocator();
    rclc_support_t support;

    // 创建rcl初始化选项
    rcl_init_options_t init_options = rcl_get_zero_initialized_init_options();
    RCCHECK(rcl_init_options_init(&init_options, allocator));
    
    // 修改ROS域ID
    RCCHECK(rcl_init_options_set_domain_id(&init_options, ROS_DOMAIN_ID));

    // 初始化rmw选项
    rmw_init_options_t *rmw_options = rcl_init_options_get_rmw_init_options(&init_options);

    // 设置静态代理IP和端口
    RCCHECK(rmw_uros_options_set_udp_address(ROS_AGENT_IP, ROS_AGENT_PORT, rmw_options));

    // 尝试连接代理
    while (1)
    {
        ESP_LOGI(TAG, "Connecting agent: %s:%s", ROS_AGENT_IP, ROS_AGENT_PORT);
        rcl_ret_t result = rclc_support_init_with_options(&support, 0, NULL, &init_options, &allocator);
        if (result == RCL_RET_OK)
        {
            ESP_LOGI(TAG, "Connected agent: %s:%s", ROS_AGENT_IP, ROS_AGENT_PORT);
            break;
        }
        ESP_LOGE(TAG, "Failed to connect agent, error: %ld, retrying...", result);
        vTaskDelay(pdMS_TO_TICKS(1000));
    }
    
    // 创建ROS2节点
    rcl_node_t node;
    RCCHECK(rclc_node_init_default(&node, "quaternion_subscriber", ROS_NAMESPACE, &support));

    // 创建订阅者
    RCCHECK(rclc_subscription_init_default(
        &quaternion_subscriber,
        &node,
        ROSIDL_GET_MSG_TYPE_SUPPORT(geometry_msgs, msg, Quaternion),
        "/cmd_quaternion"));

    // 创建执行者
    rclc_executor_t executor;
    int handle_num = 1;
    RCCHECK(rclc_executor_init(&executor, &support.context, handle_num, &allocator));
    
    // 创建临时消息变量用于订阅（实际数据会通过队列传递）
    geometry_msgs__msg__Quaternion *temp_msg = (geometry_msgs__msg__Quaternion *)malloc(sizeof(geometry_msgs__msg__Quaternion));
    if (temp_msg == NULL) {
        ESP_LOGE(TAG, "Failed to allocate memory for temp message");
        vTaskDelete(NULL);
    }
    
    // 向执行器添加订阅者
    RCCHECK(rclc_executor_add_subscription(
        &executor,
        &quaternion_subscriber,
        temp_msg,
        &quaternion_callback,
        ON_NEW_DATA));

    ESP_LOGI(TAG, "MicroROS subscriber started, listening on /cmd_quaternion");

    // 循环执行microROS任务
    while (1)
    {
        rcl_ret_t rc = rclc_executor_spin_some(&executor, RCL_MS_TO_NS(10));  // 减少超时时间到10ms
        if (rc != RCL_RET_OK) {
            ESP_LOGE(TAG, "Executor spin error: %ld", rc);
        }
        // 减少延迟以提高响应性
        usleep(1000);  // 1ms延迟
    }

    // 释放资源（正常情况下不会执行到这里）
    free(temp_msg);
    RCCHECK(rcl_subscription_fini(&quaternion_subscriber, &node));
    RCCHECK(rcl_node_fini(&node));
    RCCHECK(rclc_support_fini(&support));

    vTaskDelete(NULL);
}

void app_main(void)
{
    ESP_LOGI(TAG, "Starting car control system...");
    
    // 初始化电机
    ESP_LOGI(TAG, "Initializing motors...");
    Motor_Init();
    
    // 创建运动指令队列
    ESP_LOGI(TAG, "Creating motion queue (size: %d)...", MOTION_QUEUE_SIZE);
    motion_queue = xQueueCreate(MOTION_QUEUE_SIZE, sizeof(MotionCommand));
    if (motion_queue == NULL) {
        ESP_LOGE(TAG, "Failed to create motion queue!");
        vTaskDelete(NULL);
    }
    
    // 初始化网络，连接WiFi信号
    ESP_LOGI(TAG, "Initializing network interface...");
    ESP_ERROR_CHECK(uros_network_interface_initialize());
    
    // 创建运动处理任务
    ESP_LOGI(TAG, "Creating motion processing task...");
    BaseType_t xReturn = xTaskCreate(
        motion_processing_task,
        "motion_task",
        4096,  // 堆栈大小
        NULL,
        5,     // 优先级（高于microROS任务）
        &motion_task_handle
    );
    
    if (xReturn != pdPASS) {
        ESP_LOGE(TAG, "Failed to create motion processing task!");
        vTaskDelete(NULL);
    }
    
    // 创建监控任务（可选）
    ESP_LOGI(TAG, "Creating monitoring task...");
    xReturn = xTaskCreate(
        monitoring_task,
        "monitor_task",
        2048,  // 堆栈大小
        NULL,
        1,     // 低优先级
        NULL
    );
    
    if (xReturn != pdPASS) {
        ESP_LOGW(TAG, "Failed to create monitoring task, continuing without it");
    }
    
    // 开启microROS任务
    ESP_LOGI(TAG, "Creating microROS task...");
    xTaskCreate(
        micro_ros_task,
        "micro_ros_task",
        CONFIG_MICRO_ROS_APP_STACK,
        NULL,
        3,     // 优先级（低于运动处理任务）
        NULL
    );
    
    ESP_LOGI(TAG, "System initialization complete. Ready for commands.");
}